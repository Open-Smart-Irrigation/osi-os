[
  {
    "id": "farming_api_tab",
    "type": "tab",
    "label": "Open Smart irrigation API",
    "disabled": false,
    "info": "Authentication and device management API for Open Smart irrigation module"
  },
  {
    "id": "http_register",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "POST /auth/register",
    "url": "/auth/register",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 80,
    "wires": [["validate_register"]]
  },
  {
    "id": "validate_register",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Validate & Hash Password",
    "func": "const bcrypt = global.get('bcrypt');\nconst { username, password } = msg.payload;\n\n// Validation\nif (!username || !password) {\n    msg.statusCode = 400;\n    msg.payload = { success: false, message: 'Username and password required' };\n    return [null, msg];\n}\n\nif (password.length < 6) {\n    msg.statusCode = 400;\n    msg.payload = { success: false, message: 'Password must be at least 6 characters' };\n    return [null, msg];\n}\n\nif (username.length < 3) {\n    msg.statusCode = 400;\n    msg.payload = { success: false, message: 'Username must be at least 3 characters' };\n    return [null, msg];\n}\n\n// Hash password\nconst saltRounds = 10;\nconst hashedPassword = bcrypt.hashSync(password, saltRounds);\n\nmsg.username = username;\nmsg.hashedPassword = hashedPassword;\n\nreturn [msg, null];",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 80,
    "wires": [["db_insert_user"], ["http_response_register"]]
  },
  {
    "id": "db_insert_user",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Insert User to DB",
    "func": "const db = global.get('database');\n\nconst query = `\n    INSERT INTO users (username, password_hash, created_at)\n    VALUES (?, ?, datetime('now'))\n`;\n\ntry {\n    const stmt = db.prepare(query);\n    stmt.run(msg.username, msg.hashedPassword);\n    \n    msg.statusCode = 201;\n    msg.payload = { success: true, message: 'User registered successfully' };\n} catch (err) {\n    if (err.message.includes('UNIQUE constraint failed')) {\n        msg.statusCode = 409;\n        msg.payload = { success: false, message: 'Username already exists' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { success: false, message: 'Database error: ' + err.message };\n    }\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 630,
    "y": 80,
    "wires": [["http_response_register"]]
  },
  {
    "id": "http_response_register",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 860,
    "y": 80,
    "wires": []
  },
  {
    "id": "http_login",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "POST /auth/login",
    "url": "/auth/login",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 120,
    "y": 180,
    "wires": [["validate_login"]]
  },
  {
    "id": "validate_login",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Verify Credentials",
    "func": "const bcrypt = global.get('bcrypt');\nconst jwt = global.get('jwt');\nconst db = global.get('database');\nconst { username, password } = msg.payload;\n\n// Validation\nif (!username || !password) {\n    msg.statusCode = 400;\n    msg.payload = { message: 'Username and password required' };\n    return msg;\n}\n\n// Get user from database\nconst query = 'SELECT * FROM users WHERE username = ?';\nconst user = db.prepare(query).get(username);\n\nif (!user) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Invalid credentials' };\n    return msg;\n}\n\n// Verify password\nconst passwordValid = bcrypt.compareSync(password, user.password_hash);\n\nif (!passwordValid) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Invalid credentials' };\n    return msg;\n}\n\n// Generate JWT token\nconst token = jwt.sign(\n    { userId: user.id, username: user.username },\n    process.env.JWT_SECRET || 'your-secret-key-change-this',\n    { expiresIn: '7d' }\n);\n\nmsg.statusCode = 200;\nmsg.payload = { token };\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 370,
    "y": 180,
    "wires": [["http_response_login"]]
  },
  {
    "id": "http_response_login",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 600,
    "y": 180,
    "wires": []
  },
  {
    "id": "http_get_devices",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "GET /api/devices",
    "url": "/api/devices",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 300,
    "wires": [["verify_jwt_get_devices"]]
  },
  {
    "id": "verify_jwt_get_devices",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Verify JWT",
    "func": "const jwt = global.get('jwt');\nconst authHeader = msg.req.headers.authorization;\n\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Unauthorized' };\n    return [null, msg];\n}\n\nconst token = authHeader.substring(7);\n\ntry {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key-change-this');\n    msg.user = decoded;\n    return [msg, null];\n} catch (err) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Invalid token' };\n    return [null, msg];\n}",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 360,
    "y": 300,
    "wires": [["db_get_devices"], ["http_response_get_devices"]]
  },
  {
    "id": "db_get_devices",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Get Devices from DB",
    "func": "const db = global.get('database');\n\nconst query = `\n    SELECT \n        d.*,\n        dd.swt_wm1,\n        dd.swt_wm2,\n        dd.light_lux,\n        dd.recorded_at\n    FROM devices d\n    LEFT JOIN (\n        SELECT deveui, swt_wm1, swt_wm2, light_lux, recorded_at,\n               ROW_NUMBER() OVER (PARTITION BY deveui ORDER BY recorded_at DESC) as rn\n        FROM device_data\n    ) dd ON d.deveui = dd.deveui AND dd.rn = 1\n    WHERE d.user_id = ?\n    ORDER BY d.created_at DESC\n`;\n\nconst devices = db.prepare(query).all(msg.user.userId);\n\n// Format response\nconst formattedDevices = devices.map(d => ({\n    deveui: d.deveui,\n    name: d.name,\n    type_id: d.type_id,\n    last_seen: d.recorded_at || d.updated_at,\n    latest_data: {\n        swt_wm1: d.swt_wm1,\n        swt_wm2: d.swt_wm2,\n        light_lux: d.light_lux\n    },\n    current_state: d.current_state,\n    target_state: d.target_state\n}));\n\nmsg.statusCode = 200;\nmsg.payload = formattedDevices;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 600,
    "y": 300,
    "wires": [["http_response_get_devices"]]
  },
  {
    "id": "http_response_get_devices",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 840,
    "y": 300,
    "wires": []
  },
  {
    "id": "http_add_device",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "POST /api/devices",
    "url": "/api/devices",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 400,
    "wires": [["verify_jwt_add_device"]]
  },
  {
    "id": "verify_jwt_add_device",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Verify JWT",
    "func": "const jwt = global.get('jwt');\nconst authHeader = msg.req.headers.authorization;\n\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Unauthorized' };\n    return [null, msg];\n}\n\nconst token = authHeader.substring(7);\n\ntry {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key-change-this');\n    msg.user = decoded;\n    return [msg, null];\n} catch (err) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Invalid token' };\n    return [null, msg];\n}",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 360,
    "y": 400,
    "wires": [["db_insert_device"], ["http_response_add_device"]]
  },
  {
    "id": "db_insert_device",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Insert Device to DB",
    "func": "const db = global.get('database');\nconst { deveui, name, type_id } = msg.payload;\n\n// Validation\nif (!deveui || !name || !type_id) {\n    msg.statusCode = 400;\n    msg.payload = { message: 'deveui, name, and type_id are required' };\n    return msg;\n}\n\nif (!/^[0-9A-Fa-f]{16}$/.test(deveui)) {\n    msg.statusCode = 400;\n    msg.payload = { message: 'deveui must be 16 hexadecimal characters' };\n    return msg;\n}\n\nif (!['KIWI_SENSOR', 'STREGA_VALVE'].includes(type_id)) {\n    msg.statusCode = 400;\n    msg.payload = { message: 'Invalid device type' };\n    return msg;\n}\n\nconst query = `\n    INSERT INTO devices (deveui, name, type_id, user_id, created_at, updated_at)\n    VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))\n`;\n\ntry {\n    const stmt = db.prepare(query);\n    stmt.run(deveui.toUpperCase(), name, type_id, msg.user.userId);\n    \n    // Return the created device\n    const device = db.prepare('SELECT * FROM devices WHERE deveui = ?').get(deveui.toUpperCase());\n    \n    msg.statusCode = 201;\n    msg.payload = {\n        deveui: device.deveui,\n        name: device.name,\n        type_id: device.type_id,\n        last_seen: device.updated_at,\n        latest_data: {},\n        current_state: device.current_state,\n        target_state: device.target_state\n    };\n} catch (err) {\n    if (err.message.includes('UNIQUE constraint failed')) {\n        msg.statusCode = 409;\n        msg.payload = { message: 'Device with this DevEUI already exists' };\n    } else {\n        msg.statusCode = 500;\n        msg.payload = { message: 'Database error: ' + err.message };\n    }\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 610,
    "y": 400,
    "wires": [["http_response_add_device"]]
  },
  {
    "id": "http_response_add_device",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 860,
    "y": 400,
    "wires": []
  },
  {
    "id": "http_get_catalog",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "GET /api/catalog",
    "url": "/api/catalog",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 500,
    "wires": [["return_catalog"]]
  },
  {
    "id": "return_catalog",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Return Device Types",
    "func": "msg.statusCode = 200;\nmsg.payload = [\n    { id: 'KIWI_SENSOR', name: 'Kiwi Soil Sensor' },\n    { id: 'STREGA_VALVE', name: 'Strega Smart Valve' }\n];\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 500,
    "wires": [["http_response_catalog"]]
  },
  {
    "id": "http_response_catalog",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 620,
    "y": 500,
    "wires": []
  },
  {
    "id": "http_valve_control",
    "type": "http in",
    "z": "farming_api_tab",
    "name": "POST /api/valve/:deveui",
    "url": "/api/valve/:deveui",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 600,
    "wires": [["verify_jwt_valve"]]
  },
  {
    "id": "verify_jwt_valve",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Verify JWT",
    "func": "const jwt = global.get('jwt');\nconst authHeader = msg.req.headers.authorization;\n\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Unauthorized' };\n    return [null, msg];\n}\n\nconst token = authHeader.substring(7);\n\ntry {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key-change-this');\n    msg.user = decoded;\n    return [msg, null];\n} catch (err) {\n    msg.statusCode = 401;\n    msg.payload = { message: 'Invalid token' };\n    return [null, msg];\n}",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 360,
    "y": 600,
    "wires": [["db_update_valve"], ["http_response_valve"]]
  },
  {
    "id": "db_update_valve",
    "type": "function",
    "z": "farming_api_tab",
    "name": "Update Valve State",
    "func": "const db = global.get('database');\nconst deveui = msg.req.params.deveui.toUpperCase();\nconst { action } = msg.payload;\n\n// Validation\nif (!action || !['OPEN', 'CLOSE'].includes(action)) {\n    msg.statusCode = 400;\n    msg.payload = { message: 'action must be OPEN or CLOSE' };\n    return msg;\n}\n\n// Check if device exists and is a valve\nconst device = db.prepare('SELECT * FROM devices WHERE deveui = ? AND user_id = ?').get(deveui, msg.user.userId);\n\nif (!device) {\n    msg.statusCode = 404;\n    msg.payload = { message: 'Device not found' };\n    return msg;\n}\n\nif (device.type_id !== 'STREGA_VALVE') {\n    msg.statusCode = 400;\n    msg.payload = { message: 'Device is not a valve' };\n    return msg;\n}\n\n// Update target state\nconst targetState = action === 'OPEN' ? 'OPEN' : 'CLOSED';\nconst query = 'UPDATE devices SET target_state = ?, updated_at = datetime(\"now\") WHERE deveui = ?';\ndb.prepare(query).run(targetState, deveui);\n\n// In a real system, you would send a LoRaWAN downlink here\n// For now, we'll simulate instant response by also updating current_state\nconst updateCurrent = 'UPDATE devices SET current_state = ? WHERE deveui = ?';\ndb.prepare(updateCurrent).run(targetState, deveui);\n\nmsg.statusCode = 200;\nmsg.payload = { \n    success: true, \n    message: `Valve ${action.toLowerCase()}ed`,\n    deveui: deveui,\n    state: targetState\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 600,
    "y": 600,
    "wires": [["http_response_valve"]]
  },
  {
    "id": "http_response_valve",
    "type": "http response",
    "z": "farming_api_tab",
    "name": "Response",
    "statusCode": "",
    "headers": {},
    "x": 860,
    "y": 600,
    "wires": []
  }
]
